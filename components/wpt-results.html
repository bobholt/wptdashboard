<!--
Copyright 2017 Google Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<link rel="import" href="/bower_components/polymer/polymer-element.html">
<link rel="import" href="/bower_components/polymer/lib/elements/dom-if.html">
<link rel="import" href="/bower_components/polymer/lib/elements/dom-repeat.html">

<dom-module id="wpt-results">
  <template>
    <style>
      :host {
        display: block;
        font-size: 16px;
      }
      section.search {
        border-bottom: solid 1px #ccc;
        padding-bottom: 1em;
        margin-bottom: 1em;
      }
      input.query {
        font-size: 16px;
        display: block;
        padding: 0.5em 0;
        width: 100%;
      }
      table {
        width: 100%;
        border-collapse: collapse;
      }
      th.browser img {
        width: 32px;
        height: 32px;
      }
      tr.spec {
        background-color: #eee;
      }
      tr td {
        padding: 0 0.5em;
      }
      tr.spec td {
        padding: 0.2em 0.5em;
        border: solid 1px #ccc;
      }
    </style>

    <section class="search">
      <input
        value="{{query::input}}"
        class="query"
        placeholder="Search test files, like cors/allow-headers.htm">
    </section>

    <table>
      <thead>
        <tr>
          <th>Spec</th>
          <template is="dom-repeat" items="{{testRuns}}">
            <th class="browser">
              <div><img src="/static/{{item.browser_name}}_64x64.png" /></div>
              <div>{{item.browser_name}} {{item.browser_version}}</div>
              <div>{{item.os_name}} {{item.os_version}}</div>
              <div>@{{item.revision}}</div>
              <div>{{_dateFormat(item.created_at)}}</div>
            </th>
          </template>
        </tr>
      </thead>
      <tbody>

        <template is="dom-repeat" items="{{displayedSpecs}}" as="spec" id="spec_list">

          <tr class="spec">
            <td><b>{{spec.specName}}</b></td>

            <template is="dom-repeat" items="{{spec.results}}" as="result">
              <td>{{ _passingPercent(result) }}% ({{ result.passing }} / {{ result.total }})</td>
            </template>
          </tr>

          <!-- TODO(jeffcarp): This nested sort isn't working -->
          <template is="dom-repeat" items="{{spec.testFiles}}" as="testFile" class="test_file_list">
            <tr>
              <!-- This is the only way I've found to get sub-lists to update -->
              <td>{{ testFile.testFile }} <span style="display:none;">{{query}}</span></td>

              <template is="dom-repeat" items="{{testFile.results}}" as="result">
                <td style="{{ _testResultStyle(result) }}">
                  {{ _passingPercent(result) }}% ({{ result.passing }}/{{ result.total }})
                  <span style="display:none;">{{query}}</span>
                </td>
              </template>
            </tr>
          </template>

          <template is="dom-if" if="{{ spec.notAllTestFilesShown }}">
            <!-- TODO(jeffcarp): add a button to show more results -->
            <div>not all matching test files shown</div>
          </template>

        </template>
      </tbody>
    </table>

  </template>

  <script>
    class WPTResults extends Polymer.Element {
      static get is() { return 'wpt-results' }

      static get properties() {
        return {
          query: {
            type: String,
            value: '',
            observer: '_queryChanged'
          },
          specs: {
            type: Object,
            value: {}
          },
          displayedSpecs: {
            type: Array,
            value: []
          },
          testRuns: {
            type: Array,
          },
        };
      }

      async connectedCallback() {
        super.connectedCallback();

        const testFileResults = await Promise.all(this.testRuns.map(testRun => {
          return this._fetchResults(testRun.results_url)
        }))

        let specs = []

        testFileResults.forEach(result => {
          const testFiles = result.testFiles
          const resultsURL = result.resultsURL
          const encodedResultsURL = btoa(result.resultsURL)

          Object.keys(result.testFiles).forEach(testFileName => {
            const specName = this._specFromTestPath(testFileName)

            if (!(specName in this.specs)) {
              this.specs[specName] = {results: {}, specName: specName, testFiles: {}}
            }
            if (!(encodedResultsURL in this.specs[specName].results)) {
              this.specs[specName].results[encodedResultsURL] = {resultsURL: resultsURL, passing: 0, total: 0}
            }
            this.specs[specName].results[encodedResultsURL].passing += testFiles[testFileName][0]
            this.specs[specName].results[encodedResultsURL].total += testFiles[testFileName][1]
            if (!(testFileName in this.specs[specName].testFiles)) {
              this.specs[specName].testFiles[testFileName] = {testFile: testFileName, results: {}}
            }
            if (!(encodedResultsURL in this.specs[specName].testFiles[testFileName].results)) {
              this.specs[specName].testFiles[testFileName].results[encodedResultsURL] = {resultsURL: resultsURL, passing: 0, total: 0}
            }
            this.specs[specName].testFiles[testFileName].results[encodedResultsURL].passing = testFiles[testFileName][0]
            this.specs[specName].testFiles[testFileName].results[encodedResultsURL].total = testFiles[testFileName][1]
          })
        })

        this._refreshDisplayedSpecs()
      }

      _specFilter(spec) {
        if (this.query.length === 0) {
          return true
        }

        const matchesQuery = (tf) => tf.testFile.toLowerCase().includes(this.query.toLowerCase())
        return spec.testFiles.some(matchesQuery)
      }

      _testFileFilter(testFile) {
        if (this.query.length < 3) {
          return false
        }

        return testFile.testFile.toLowerCase().includes(this.query.toLowerCase())
      }

      _testFileSort(a, b) {
        if (a.testFile < b.testFile) return -1;
        if (a.testFile > b.testFil) return 1;
        return 0;
      }

      _specSort(a, b) {
        if (a.specName < b.specName) return -1;
        if (a.specName > b.specName) return 1;
        return 0;
      }

      _resultWithRunIndex(results, runIndex) {
        for (var key in results) {
          if (results[key].runIndex === runIndex) {
            return results[key]
          }
        }
      }

      _specFromTestPath(path) {
        return path.split('/')[1]
      }

      async _fetchResults(url) {
        const response = await fetch(url)
        const testFiles = await response.json()
        return {testFiles: testFiles, resultsURL: url}

      }

      _queryChanged() {
        this._refreshDisplayedSpecs()
      }

      _refreshDisplayedSpecs() {
        const matchesQuery = (tf) => tf.testFile.toLowerCase().includes(this.query.toLowerCase())
        const displayedSpecs = []

        for (var key in this.specs) {
          let spec = this.specs[key]
          let displaySpec = {}

          displaySpec.specName = spec.specName
          displaySpec.results = this.testRuns.map(testRun => {
            let key = btoa(testRun.results_url)
            return spec.results[key]
          })

          if (this.query.length < 3) {
            displaySpec.testFiles = []
            displayedSpecs.push(displaySpec)
            continue
          }

          let allTestFiles = Object.keys(spec.testFiles).map(k => {
            let displayTestFile = {}
            let originalTestFile = spec.testFiles[k]

            displayTestFile.testFile = originalTestFile.testFile
            displayTestFile.results = this.testRuns.map(testRun => {
              let key = btoa(testRun.results_url)
              return originalTestFile.results[key]
            })

            return displayTestFile
          })

          const MAX_RESULTS_PER_SPEC = 10

          let matchingTestFiles = allTestFiles.filter(matchesQuery)
          if (matchingTestFiles.length > 0) {
            displaySpec.testFiles = matchingTestFiles.slice(0, MAX_RESULTS_PER_SPEC)
            displaySpec.notAllTestFilesShown = matchingTestFiles.length > MAX_RESULTS_PER_SPEC
            displayedSpecs.push(displaySpec)
          }
        }
        this.set('displayedSpecs', displayedSpecs)
      }

      _passingPercent(item) {
        if (!item || isNaN(item.passing) || isNaN(item.total)) return ''
        return parseFloat((item.passing / item.total) * 100).toFixed(1)
      }

      _platformID(testRun) {
        return `${testRun.browser_name}-${testRun.browser_version}-${testRun.os_name}-${testRun.os_version}`
      }

      /* Function for getting total numbers.
       * Intentionally not exposed in UI.
       * To generate, open your console and run:
       * document.querySelector('wpt-results').generateTotalPassNumbers()
       */
      generateTotalPassNumbers() {
        const totals = {}

        this.testRuns.forEach(testRun => {
          const testRunKey = btoa(testRun.results_url)
          const testRunID = this._platformID(testRun)
          totals[testRunID] = {passing: 0, total: 0}

          Object.keys(this.specs).forEach(specKey => {
            totals[testRunID].passing += this.specs[specKey].results[testRunKey].passing
            totals[testRunID].total += this.specs[specKey].results[testRunKey].total
          })
        })

        Object.keys(totals).forEach(key => {
          totals[key].percent = (totals[key].passing / totals[key].total) * 100
        })

        console.table(Object.keys(totals).map(k => ({
          platformID: k,
          passing: totals[k].passing,
          total: totals[k].total,
          percent: totals[k].percent
        })))

        console.log('JSON version:', JSON.stringify(totals))
        return
      }

      _dateFormat(dateStr) {
        return String(new Date(dateStr)).match(/^\w+ (\w+ \w+ \w+)/)[1]
      }

      _testResultStyle(result) {
        if (!result) return ''

        // Need saturation between 65-100, reversed (range 35)
        const passRate = result.passing / result.total
        if (passRate === 1) {
          // Green
          return 'background-color: hsl(129, 85%, 65%)'
        } else {
          const luminance = 65 + passRate * 20
          // Some shade of red
          return `background-color: hsl(0, 85%, ${luminance}%)`
        }
      }
    }

    customElements.define(WPTResults.is, WPTResults);
  </script>
</dom-module>
